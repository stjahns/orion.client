/*******************************************************************************
 * Copyright (c) 2011 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
/*global window widgets eclipse:true orion:true serviceRegistry dojo dijit */
/*jslint maxerr:150 browser:true devel:true regexp:false*/


/**
 * @namespace The global container for orion APIs.
 */ 
var eclipse = eclipse || {};
var orion = orion || {};

orion.EditorCommandFactory = (function() {
	function EditorCommandFactory (serviceRegistry, commandService, fileClient, toolbarId) {
		this.serviceRegistry = serviceRegistry;
		this.commandService = commandService;
		this.fileClient = fileClient;
		this.toolbarId = toolbarId;
	}
	EditorCommandFactory .prototype = {
		/**
		 * Creates the common text editing commands.  Also generates commands for any installed plug-ins that
		 * contribute editor actions.  
		 */
		generateEditorCommands: function(editor) {
			// create commands common to all editors
			editor.getEditorWidget().setKeyBinding(new eclipse.KeyBinding('s', true), "orion.save");
			editor.getEditorWidget().setAction("orion.save", dojo.hitch(this, function () {
				var contents = editor.getEditorWidget().getText();
				this.fileClient.write(editor.getFileURI(), contents).then(function() {
					editor.onInputChange(editor.getFileURI(), null, contents, true);
				});
			}));
			var saveCommand = new eclipse.Command({
				name: "Save",
				image: "images/save_edit.gif",
				id: "orion.save",
				callback: function(editor) {
					editor.getEditorWidget().invokeAction("orion.save");
				}});
			this.commandService.addCommand(saveCommand, "dom");
			this.commandService.addCommandGroup("orion.editorActions.unlabeled", 200, null, null, this.toolbarId);
			this.commandService.registerCommandContribution("orion.save", 1, this.toolbarId, "orion.editorActions.unlabeled");
	
			// add the commands generated by plug-ins who implement the "editorActions" extension.
			// we currently position these first so that the regular commands always appear in the same place (on the right) regardless of installed plug-ins
			// eventually we should define command groups that are more functional in nature and that would require the extension knowing where it wants to be
			this.commandService.addCommandGroup("orion.editorActions.contributed.noImages", 100, "More", null, this.toolbarId);
			this.commandService.addCommandGroup("orion.editorActions.contributed.images", 101, null, null, this.toolbarId);
	
			// Note that the shape of the "editorActions" extension is not in any shape or form that could be considered final.
			// We've included it to enable experimentation. Please provide feedback in the following bug:
			// https://bugs.eclipse.org/bugs/show_bug.cgi?id=337766
	
			// The shape of the contributed actions is (for now):
			// info - information about the action (object).
			//        required attribute: name - the name of the action
			//        optional attribute: key - an array with values to pass to the eclipse.KeyBinding constructor
			//        optional attribute: img - a URL to an image for the action
			// run - the implementation of the action (function).
			//        arguments passed to run: (selectedText, fullText, selection)
			//          selectedText (string) - the currently selected text in the editor
			//          fullText (string) - the complete text of the editor
			//          selection (object) - an object with attributes: start, end
			//        the return value of the run function will be used as follows:
			//          if the return value is a string, the current selection in the editor will be replaced with the returned string
			//          if the return value is an object, its "text" attribute (required) will be used to replace the contents of the editor,
			//                                            and its "selection" attribute (optional) will be used to set the new selection.
		
			// iterate through the extension points and generate commands for each one.
			var actionReferences = this.serviceRegistry.getServiceReferences("editorAction");
			
			// KB exists so that we can pass an array (from info.key) rather than actual arguments
			function KB(args) {
				return eclipse.KeyBinding.apply(this, args);
			}
		
			for (var i=0; i<actionReferences.length; i++) {
				serviceRegistry.getService(actionReferences[i]).then(function(service) {
					var info = {};
					var propertyNames = actionReferences[i].getPropertyNames();
					for (var j = 0; j < propertyNames.length; j++) {
						info[propertyNames[j]] = actionReferences[i].getProperty(propertyNames[j]);
					}
					var editorWidget = editor.getEditorWidget();
					var command = new eclipse.Command({
						name: info.name,
						image: info.img,
						id: info.name,
						callback: dojo.hitch(editor, function(editor) {
							// command service will provide editor parameter but editor widget callback will not
							var editorWidget = editor ? editor.getEditorWidget() : this.getEditorWidget();
							var text = editorWidget.getText();
							var selection = editorWidget.getSelection();
							service.run(editorWidget.getText(selection.start,selection.end),text,selection).then(function(result){
								if (result.text) {
									editorWidget.setText(result.text);
									if (result.selection) {
										editorWidget.setSelection(result.selection.start, result.selection.end);
										editorWidget.focus();
									}
								} else {
									if (typeof result === 'string') {
										editorWidget.setText(result, selection.start, selection.end);
										editorWidget.setSelection(selection.start, selection.end);
										editorWidget.focus();
									}
								}
							});
							
						})});
					this.commandService.addCommand(command, "dom");
					if (info.img) {
						// image will be placed on toolbar
						this.commandService.registerCommandContribution(command.id, i, this.toolbarId, "orion.editorActions.contributed.images");
					} else {
						// if there is no image it will be grouped in a "More..." menu button
						this.commandService.registerCommandContribution(command.id, i, this.toolbarId, "orion.editorActions.contributed.noImages");
					}
					// We must regenerate the command toolbar everytime we process an extension because
					// this is asynchronous and we probably have already populated the toolbar.
					// In the editor, we generate page level commands to the banner.
					eclipse.globalCommandUtils.generateDomCommandsInBanner(this.commandService, editor);
		
					if (info.key) {
						// add it to the editor as a keybinding
						KB.prototype = eclipse.KeyBinding.prototype;
						editorWidget.setKeyBinding(new KB(info.key), command.id);
						editorWidget.setAction(command.id, command.callback);
					}
				});
			}
		}
	};
	return EditorCommandFactory;
}());

orion.UndoFactory = (function() {
	function UndoFactory(serviceRegistry, commandService, toolbarId) {
		this.serviceRegistry = serviceRegistry;
		this.commandService = commandService;
		this.toolbarId = toolbarId;
	}
	UndoFactory.prototype = {
		createUndoStack: function(editor) {
			var undoStack =  new eclipse.UndoStack(editor.getEditorWidget(), 200);
			editor.getEditorWidget().setKeyBinding(new eclipse.KeyBinding('z', true), "orion.undo");
			editor.getEditorWidget().setAction("orion.undo", function() {
				undoStack.undo();
				return true;
			});
			var undoCommand = new eclipse.Command({
				name: "Undo",
				image: "images/undo_edit.gif",
				id: "orion.undo",
				callback: function(editor) {
					editor.getEditorWidget().invokeAction("orion.undo");
				}});
			this.commandService.addCommand(undoCommand, "dom");
			
			var isMac = navigator.platform.indexOf("Mac") !== -1;
			editor.getEditorWidget().setKeyBinding(isMac ? new eclipse.KeyBinding('z', true, true) : new eclipse.KeyBinding('y', true), "orion.redo");
			editor.getEditorWidget().setAction("orion.redo", function() {
				undoStack.redo();
				return true;
			});
	
			var redoCommand = new eclipse.Command({
				name: "Redo",
				image: "images/redo_edit.gif",
				id: "orion.redo",
				callback: function(editor) {
					editor.getEditorWidget().invokeAction("orion.redo");
				}});
			this.commandService.addCommand(redoCommand, "dom");
	
			this.commandService.registerCommandContribution("orion.undo", 400, this.toolbarId, "orion.editorActions.unlabeled");
			this.commandService.registerCommandContribution("orion.redo", 401, this.toolbarId, "orion.editorActions.unlabeled");

			return undoStack;
		}
	};
	return UndoFactory;
}());

orion.LineNumberRulerFactory = (function() {
	function LineNumberRulerFactory() {
	}
	LineNumberRulerFactory.prototype = {
		createLineNumberRuler: function() {
			return new eclipse.LineNumberRuler("left", {style: {backgroundColor: "#ffffff", textAlign: "right", borderLeft:"1px solid #ddd", borderRight:"1px solid #ddd"}}, {style: { backgroundColor: "#ffffff" }}, {style: { backgroundColor: "#ffffff" }});
		}
	};
	return LineNumberRulerFactory;
}());


orion.AnnotationFactory = (function() {
	function AnnotationFactory() {
	}
	AnnotationFactory.prototype = {
		createAnnotationRulers: function() {
			var rulerStyle = {style: { backgroundColor: "#ffffff" }};
			var annotationRuler = new eclipse.AnnotationRuler("left", rulerStyle, {html: "<img src='images/problem.gif'></img>"});
			var overviewRuler = new eclipse.OverviewRuler("right", rulerStyle, annotationRuler);
			return {annotationRuler: annotationRuler, overviewRuler: overviewRuler};
		}
	};
	return AnnotationFactory;
}());

/**
 * TextCommands connects common text editing keybindings onto an editor.
 */
orion.TextCommands = (function() {
	function TextCommands(editor, undoStack) {
		this.editor = editor;
		this.editorWidget = editor.getEditorWidget();
		this.undoStack = undoStack;
		this._incrementalFindActive = false;
		this._incrementalFindSuccess = true;
		this._incrementalFindIgnoreSelection = false;
		this._incrementalFindPrefix = "";

		this.init();
	}
	TextCommands.prototype = {
		init: function() {
			this._incrementalFindListener = {
				onVerify: dojo.hitch(this, function(event){
					var prefix = this._incrementalFindPrefix,
						txt = this.editorWidget.getText(event.start, event.end),
						match = prefix.match(new RegExp("^"+dojo.regexp.escapeString(txt), "i"));
					if (match && match.length > 0) {
						prefix = this._incrementalFindPrefix += event.text;
						this.editor.reportStatus("Incremental find: " + prefix);
						var ignoreCase = prefix.toLowerCase() === prefix;
						var result = this.editor.doFind(prefix, this.editorWidget.getSelection().start, ignoreCase);
						if (result) {
							this._incrementalFindSuccess = true;
							this._incrementalFindIgnoreSelection = true;
							this.editor.moveSelection(this.editorWidget, result.index, result.index+result.length);
							this._incrementalFindIgnoreSelection = false;
						} else {
							this.editor.reportStatus("Incremental find: " + prefix + " (not found)", true);
							this._incrementalFindSuccess = false;
						}
						event.text = null;
					} else {
					}
				}),
				onSelection: dojo.hitch(this, function() {
					if (!this._incrementalFindIgnoreSelection) {
						this.toggleIncrementalFind();
					}
				})
			};
			// Find actions
			// These variables are used among the various find actions:
			var searchString = "",
			    pattern,
			    flags;
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding("f", true), "find");
			this.editorWidget.setAction("find", dojo.hitch(this, function() {
				setTimeout(dojo.hitch(this, function() {
					var selection = this.editorWidget.getSelection();
					if (selection.end > selection.start) {
						searchString = this.editorWidget.getText().substring(selection.start, selection.end);
					} else {
						searchString = "";
					}
					searchString = prompt("Enter search term or /regex/:", searchString);
					if (!searchString) {
						return;
					}
					
					var ignoreCase = searchString.toLowerCase() === searchString,
					    regexp = this.editor.parseRegExp(searchString),
					    result;
					if (regexp) {
						pattern = regexp.pattern;
						flags = regexp.flags;
						flags = flags + (ignoreCase && flags.indexOf("i") === -1 ? "i" : "");
						result = this.editor.doFindRegExp(pattern, flags, this.editorWidget.getCaretOffset());
					} else {
						pattern = null;
						flags = null;
						result = this.editor.doFind(searchString, this.editorWidget.getCaretOffset(), ignoreCase);
					}
					
					if (result) {
						this.editor.moveSelection(this.editorWidget, result.index, result.index+result.length);
					} else {
						this.editor.reportStatus("not found", true);
					}
				}), 0);
			}));
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding("k", true), "find next");
			this.editorWidget.setAction("find next", dojo.hitch(this, function() {
				var result, ignoreCase;
				if (this._incrementalFindActive) {
					var str = this._incrementalFindPrefix;
					ignoreCase = str.toLowerCase() === str;
					result = this.editor.doFind(str, this.editorWidget.getCaretOffset(), ignoreCase);
				} else if (pattern) {
					// RegExp search
					result = this.editor.doFindRegExp(pattern, flags, this.editorWidget.getCaretOffset());
				} else {
					ignoreCase = searchString.toLowerCase() === searchString;
					result = this.editor.doFind(searchString, this.editorWidget.getCaretOffset(), ignoreCase);
				}
				
				if (result) {
					this._incrementalFindIgnoreSelection = true;
					this.editor.moveSelection(this.editorWidget, result.index, result.index+result.length);
					this._incrementalFindIgnoreSelection = false;
				} else {
					this.editor.reportStatus("not found", true);
				}
			}));
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding("k", true, true), "find previous");
			this.editorWidget.setAction("find previous", dojo.hitch(this, function() {
				var selection = this.editorWidget.getSelection();
				var selectionSize = (selection.end > selection.start) ? selection.end - selection.start : 0;
				var result, ignoreCase;
				if (this._incrementalFindActive) {
					var str = this._incrementalFindPrefix;
					ignoreCase = str.toLowerCase() === str;
					result = this.editor.doFind(str, this.editorWidget.getCaretOffset() - selectionSize - 1, ignoreCase, true);
				} else if (pattern) {
					// RegExp search
					result = this.editor.doFindRegExp(pattern, flags, this.editorWidget.getCaretOffset() - selectionSize - 1, true);
				} else {
					ignoreCase = searchString.toLowerCase() === searchString;
					result = this.editor.doFind(searchString, this.editorWidget.getCaretOffset() - selectionSize - 1, ignoreCase, true);
				}
				
				if (result) {
					this._incrementalFindIgnoreSelection = true;
					this.editor.moveSelection(this.editorWidget, result.index, result.index+result.length);
					this._incrementalFindIgnoreSelection = false;
				} else {
					this.editor.reportStatus("not found", true);
				}
			}));
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding("j", true), "incremental find");
			this.editorWidget.setAction("incremental find", dojo.hitch(this, function() {
				if (!this._incrementalFindActive) {
					this.editorWidget.setCaretOffset(this.editorWidget.getCaretOffset());
					this.toggleIncrementalFind();
				} else {
					var p = this._incrementalFindPrefix;
					if (p.length === 0) {
						return;
					}
					
					var start = this.editorWidget.getSelection().start + 1;
					if (this._incrementalFindSuccess === false) {
						start = 0;
					}
					
					var caseInsensitive = p.toLowerCase() === p;
					var result = this.editor.doFind(p, start, caseInsensitive);
					if (result) {
						this._incrementalFindSuccess = true;
						this._incrementalFindIgnoreSelection = true;
						this.editor.moveSelection(this.editorWidget, result.index, result.index + result.length);
						this._incrementalFindIgnoreSelection = false;
						this.editor.reportStatus("Incremental find: " + p);
					} else {
						this.editor.reportStatus("Incremental find: " + p + " (not found)", true);
						this._incrementalFindSuccess = false;
					}
				}
				return true;
			}));
			this.editorWidget.setAction("deletePrevious", dojo.hitch(this, function() {
				if (this._incrementalFindActive) {
					var p = this._incrementalFindPrefix;
					p = this._incrementalFindPrefix = p.substring(0, p.length-1);
					if (p.length===0) {
						this._incrementalFindSuccess = true;
						this._incrementalFindIgnoreSelection = true;
						this.editorWidget.setCaretOffset(this.editorWidget.getSelection().start);
						this._incrementalFindIgnoreSelection = false;
						this.toggleIncrementalFind();
						return true;
					}
					this.editor.reportStatus("Incremental find: " + p);
					var index = this.editorWidget.getText().lastIndexOf(p, this.editorWidget.getCaretOffset() - p.length - 1);
					if (index !== -1) {
						this._incrementalFindSuccess = true;
						this._incrementalFindIgnoreSelection = true;
						this.editor.moveSelection(this.editorWidget, index,index+p.length);
						this._incrementalFindIgnoreSelection = false;
					} else {
						this.editor.reportStatus("Incremental find: " + p + " (not found)", true);
					}
					return true;
				} else {
					return false;
				}
			}));
			
			// Tab actions
			this.editorWidget.setAction("tab", dojo.hitch(this, function() {
				var selection = this.editorWidget.getSelection();
				var model = this.editorWidget.getModel();
				var firstLine = model.getLineAtOffset(selection.start);
				var lastLine = model.getLineAtOffset(selection.end>selection.start?selection.end - 1:selection.end);
				if (firstLine !== lastLine) {
					this.startUndo();
					var lineStart = model.getLineStart(firstLine);
					for (var i = firstLine; i <= lastLine; i++) {
						lineStart = model.getLineStart(i);
						this.editorWidget.setText("\t", lineStart, lineStart);
					}
					this.editorWidget.setSelection(lineStart===selection.start?lineStart:selection.start + 1, selection.end + (lastLine - firstLine + 1));
					this.endUndo();
					return true;
				}
				return false;
			}));
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding(9, false, true), "shift tab");
			this.editorWidget.setAction("shift tab", dojo.hitch(this, function() {
				var selection = this.editorWidget.getSelection();
				var model = this.editorWidget.getModel();
				var firstLine = model.getLineAtOffset(selection.start);
				var lastLine = model.getLineAtOffset(selection.end>selection.start?selection.end - 1:selection.end);
				var i, lineStart;
				for (i = firstLine; i <= lastLine; i++) {
					lineStart = model.getLineStart(i);
					var lineEnd = model.getLineEnd(i);
					if (lineStart === lineEnd) { return false; }
					if (this.editorWidget.getText(lineStart, lineStart + 1) !== "\t") { return false; }
				}
				this.startUndo();
				lineStart = model.getLineStart(firstLine);
				var lastLineStart = model.getLineStart(lastLine);
				for (i = firstLine; i <= lastLine; i++) {
					lineStart = model.getLineStart(i);
					this.editorWidget.setText("", lineStart, lineStart + 1);
				}
				this.editorWidget.setSelection(lineStart===selection.start?lineStart:selection.start - 1, selection.end - (lastLine - firstLine + 1) + (selection.end===lastLineStart+1?1:0));
				this.endUndo();
				return true;
			}));
			
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding(38, false, false, true), "move up selection");
			this.editorWidget.setAction("move up selection", dojo.hitch(this, function() {
				var selection = this.editorWidget.getSelection();
				var model = this.editorWidget.getModel();
				var firstLine = model.getLineAtOffset(selection.start);
				if (firstLine===0) {
					return true;
				}
				this.startUndo();
				var lastLine = model.getLineAtOffset(selection.end>selection.start?selection.end - 1:selection.end);
				var isMoveFromLastLine = model.getLineCount()-1===lastLine;
				var lineStart = model.getLineStart(firstLine);
				var lineEnd = isMoveFromLastLine?model.getCharCount():model.getLineStart(lastLine+1);
				if (isMoveFromLastLine) {
					// Move delimiter preceding selection to end
					var delimiterStart = model.getLineEnd(firstLine-1);
					var delimiterEnd = model.getLineEnd(firstLine-1, true);
					var delimiter = model.getText(delimiterStart, delimiterEnd);
					lineStart = delimiterStart;
					model.setText(model.getText(delimiterEnd, lineEnd)+delimiter, lineStart, lineEnd);
				}
				var text = model.getText(lineStart, lineEnd);
				model.setText("", lineStart, lineEnd);
				var insertPos = model.getLineStart(firstLine-1);
				model.setText(text, insertPos, insertPos);
				var selectionEnd = insertPos+text.length-(isMoveFromLastLine?model.getLineDelimiter().length:0);
				this.editorWidget.setSelection(insertPos, selectionEnd);
				this.endUndo();
			}));
			
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding(40, false, false, true), "move down selection");
			this.editorWidget.setAction("move down selection", dojo.hitch(this, function() {
				var selection = this.editorWidget.getSelection();
				var model = this.editorWidget.getModel();
				var firstLine = model.getLineAtOffset(selection.start);
				var lastLine = model.getLineAtOffset(selection.end>selection.start?selection.end - 1:selection.end);
				if (lastLine===model.getLineCount()-1) {
					return true;
				}
				this.startUndo();
				var isMoveIntoLastLine = lastLine===model.getLineCount()-2;
				var lineStart = model.getLineStart(firstLine);
				var lineEnd = model.getLineStart(lastLine+1);
				if (isMoveIntoLastLine) {
					// Move delimiter following selection to front
					var delimiterStart = model.getLineStart(lastLine+1)-model.getLineDelimiter().length;
					var delimiterEnd = model.getLineStart(lastLine+1);
					var delimiter = model.getText(delimiterStart, delimiterEnd);
					model.setText(delimiter + model.getText(lineStart, delimiterStart), lineStart, lineEnd);
				}
				var text = model.getText(lineStart, lineEnd);
				var insertPos = (isMoveIntoLastLine?model.getCharCount():model.getLineStart(lastLine+2))-(lineEnd-lineStart);
				model.setText("", lineStart, lineEnd);
				model.setText(text, insertPos, insertPos);
				var selStart = insertPos+(isMoveIntoLastLine?model.getLineDelimiter().length:0);
				var selEnd = insertPos+text.length;
				this.editorWidget.setSelection(selStart, selEnd);
				this.endUndo();
			}));
			
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding(38, true, false, true), "copy up selection");
			this.editorWidget.setAction("copy up selection", dojo.hitch(this, function() {
				this.startUndo();
				var selection = this.editorWidget.getSelection();
				var model = this.editorWidget.getModel();
				var delimiter = model.getLineDelimiter();
				var firstLine = model.getLineAtOffset(selection.start);
				var lastLine = model.getLineAtOffset(selection.end>selection.start?selection.end - 1:selection.end);
				var lineStart = model.getLineStart(firstLine);
				var isCopyFromLastLine = model.getLineCount()-1===lastLine;
				var lineEnd = isCopyFromLastLine?model.getCharCount():model.getLineStart(lastLine+1);
				var text = model.getText(lineStart, lineEnd)+(isCopyFromLastLine?delimiter:""); //+ delimiter;
				//var insertPos = model.getLineStart(firstLine - 1);
				var insertPos = lineStart;
				model.setText(text, insertPos, insertPos);
				this.editorWidget.setSelection(insertPos, insertPos+text.length-(isCopyFromLastLine?delimiter.length:0));
				this.endUndo();
			}));
			
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding(40, true, false, true), "copy down selection");
			this.editorWidget.setAction("copy down selection", dojo.hitch(this, function() {
				this.startUndo();
				var selection = this.editorWidget.getSelection();
				var model = this.editorWidget.getModel();
				var delimiter = model.getLineDelimiter();
				var firstLine = model.getLineAtOffset(selection.start);
				var lastLine = model.getLineAtOffset(selection.end>selection.start?selection.end - 1:selection.end);
				var lineStart = model.getLineStart(firstLine);
				var isCopyFromLastLine = model.getLineCount()-1===lastLine;
				var lineEnd = isCopyFromLastLine?model.getCharCount():model.getLineStart(lastLine+1);
				var text = (isCopyFromLastLine?delimiter:"")+model.getText(lineStart, lineEnd);
				//model.setText("", lineStart, lineEnd);
				//var insertPos = model.getLineStart(firstLine - 1);
				var insertPos = lineEnd;
				model.setText(text, insertPos, insertPos);
				this.editorWidget.setSelection(insertPos+(isCopyFromLastLine?delimiter.length:0), insertPos+text.length);
				this.endUndo();
			}));
			
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding('d', true, false, false), "delete selected lines");
			this.editorWidget.setAction("delete selected lines", dojo.hitch(this, function() {
				this.startUndo();
				var selection = this.editorWidget.getSelection();
				var model = this.editorWidget.getModel();
				var firstLine = model.getLineAtOffset(selection.start);
				var lastLine = model.getLineAtOffset(selection.end>selection.start?selection.end - 1:selection.end);
				var lineStart = model.getLineStart(firstLine);
				var lineEnd = model.getLineCount()-1===lastLine?model.getCharCount():model.getLineStart(lastLine+1);
				model.setText("", lineStart, lineEnd);
				this.endUndo();
			}));
			
			// Go To Line action
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding("l", true), "goto-line");
			this.editorWidget.setAction("goto-line", dojo.hitch(this, function() {
					var line = this.editorWidget.getModel().getLineAtOffset(this.editorWidget.getCaretOffset());
					line = prompt("Go to line:", line + 1);
					if (line) {
						line = parseInt(line, 10);
						this.editor.onGotoLine(line-1, 0);
					}
					return true;
			}));
			
		},
			
		toggleIncrementalFind: function() {
			this._incrementalFindActive = !this._incrementalFindActive;
			if (this._incrementalFindActive) {
				this.editor.reportStatus("Incremental find: " + this._incrementalFindPrefix);
				this.editorWidget.addEventListener("Verify", this, this._incrementalFindListener.onVerify);
				this.editorWidget.addEventListener("Selection", this, this._incrementalFindListener.onSelection);
			} else {
				this._incrementalFindPrefix = "";
				this.editor.reportStatus("");
				this.editorWidget.removeEventListener("Verify", this, this._incrementalFindListener.onVerify);
				this.editorWidget.removeEventListener("Selection", this, this._incrementalFindListener.onSelection);
				this.editorWidget.setCaretOffset(this.editorWidget.getCaretOffset());
			}
		},
		
		startUndo: function() {
			if (this.undoStack) {
				this.undoStack.startCompoundChange();
			}
		}, 
		
		endUndo: function() {
			if (this.undoStack) {
				this.undoStack.endCompoundChange();
			}
		}, 
	
		cancel: function() {
			this.toggleIncrementalFind();
		},
		
		isActive: function() {
			return this._incrementalFindActive;
		},
		
		lineUp: function() {
			var index;
			if (this._incrementalFindActive) {
				var p = this._incrementalFindPrefix;
				var start = this.editorWidget.getCaretOffset() - p.length - 1;
				if (this._incrementalFindSuccess === false) {
					start = this.editorWidget.getModel().getCharCount() - 1;
				}
				index = this.editorWidget.getText().lastIndexOf(p, start);
				if (index !== -1) {
					this._incrementalFindSuccess = true;
					this._incrementalFindIgnoreSelection = true;
					this.editor.moveSelection(this.editorWidget, index,index+p.length);
					this._incrementalFindIgnoreSelection = false;
				} else {
					this.editor.reportStatus("Incremental find: " + p + " (not found)", true);	
					this._incrementalFindSuccess = false;
				}
				return true;
			}
		},
		lineDown: function() {	
			var index;
			if (this._incrementalFindActive) {
				var p = this._incrementalFindPrefix;
				if (p.length===0) {
					return;
				}
				var start = this.editorWidget.getSelection().start + 1;
				if (this._incrementalFindSuccess === false) {
					start = 0;
				}
				index = this.editorWidget.getText().indexOf(p, start);
				if (index !== -1) {
					this._incrementalFindSuccess = true;
					this._incrementalFindIgnoreSelection = true;
					this.editor.moveSelection(this.editorWidget, index, index+p.length);
					this._incrementalFindIgnoreSelection = false;
					this.editor.reportStatus("Incremental find: " + p);
				} else {
					this.editor.reportStatus("Incremental find: " + p + " (not found)", true);
					this._incrementalFindSuccess = false;
				}
				return true;
			}
		},
		enter: function() {
			return false;
		}
	};
	return TextCommands;
}());

orion.SourceCommands = (function() {
	function SourceCommands(editor, undoStack, contentAssist) {
		this.editor = editor;
		this.editorWidget = editor.getEditorWidget();
		this.undoStack = undoStack;
		this.contentAssist = contentAssist;
		this.init();
	}
	SourceCommands.prototype = {
		startUndo: function() {
			if (this.undoStack) {
				this.undoStack.startCompoundChange();
			}
		}, 
		
		endUndo: function() {
			if (this.undoStack) {
				this.undoStack.endCompoundChange();
			}
		}, 
		init: function() {
		
			// Block comment operations
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding(191, true), "toggle comment");
			this.editorWidget.setAction("toggle comment", dojo.hitch(this, function() {
				this.startUndo();
				var selection = this.editorWidget.getSelection();
				var model = this.editorWidget.getModel();
				var firstLine = model.getLineAtOffset(selection.start);
				var lastLine = model.getLineAtOffset(selection.end>selection.start?selection.end - 1:selection.end);
				var uncomment = true;
				var lineText;
				for (var i = firstLine; i <= lastLine && uncomment; i++) {
					lineText = this.editorWidget.getModel().getLine(i);
					var index = lineText.indexOf("//");
					if (index === -1) {
						uncomment = false;
					} else {
						if (index !== 0) {
							var j;
							for (j=0; j<index; j++) {
								var c = lineText.charCodeAt(j);
								if (!(c === 32 || c === 9)) {
									break;
								}
							}
							uncomment = j === index;
						}
					}
				}
				var k, lineStart, lastLineStart, insertOffset;
				if (uncomment) {
					lineStart = model.getLineStart(firstLine);
					lastLineStart = model.getLineStart(lastLine);
					for (k = firstLine; k <= lastLine; k++) {
						lineText = this.editorWidget.getModel().getLine(k);
						insertOffset = lineText.indexOf("//") + model.getLineStart(k);
						this.editorWidget.setText("", insertOffset, insertOffset + 2);
					}
					this.editorWidget.setSelection(lineStart===selection.start?lineStart:selection.start - 2, selection.end - (2 * (lastLine - firstLine + 1)) + (selection.end===lastLineStart+1?2:0));
				} else {
					lineStart = model.getLineStart(firstLine);
					lastLineStart = model.getLineStart(lastLine);
					for (k = firstLine; k <= lastLine; k++) {
						insertOffset = model.getLineStart(k);
						this.editorWidget.setText("//", insertOffset, insertOffset);
					}
					this.editorWidget.setSelection(lineStart===selection.start?lineStart:selection.start + 2, selection.end + (2 * (lastLine - firstLine + 1)));
				}
				this.endUndo();
				return true;
			}));
			
			function findEnclosingComment(model, start, end) {
				var open = "/*", close = "*/";
				var firstLine = model.getLineAtOffset(start);
				var lastLine = model.getLineAtOffset(end);
				var i, line, extent, openPos, closePos;
				var commentStart, commentEnd;
				for (i=firstLine; i >= 0; i--) {
					line = model.getLine(i);
					extent = (i === firstLine) ? start - model.getLineStart(firstLine) : line.length;
					openPos = line.lastIndexOf(open, extent);
					closePos = line.lastIndexOf(close, extent);
					if (closePos > openPos) {
						break; // not inside a comment
					} else if (openPos !== -1) {
						commentStart = model.getLineStart(i) + openPos;
						break;
					}
				}
				for (i=lastLine; i < model.getLineCount(); i++) {
					line = model.getLine(i);
					extent = (i === lastLine) ? end - model.getLineStart(lastLine) : 0;
					openPos = line.indexOf(open, extent);
					closePos = line.indexOf(close, extent);
					if (openPos !== -1 && openPos < closePos) {
						break;
					} else if (closePos !== -1) {
						commentEnd = model.getLineStart(i) + closePos;
						break;
					}
				}
				return {commentStart: commentStart, commentEnd: commentEnd};
			}
			
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding(191, true, true), "add block comment");
			this.editorWidget.setAction("add block comment", dojo.hitch(this, function() {
				var selection = this.editorWidget.getSelection();
				var model = this.editorWidget.getModel();
				var open = "/*", close = "*/", commentTags = new RegExp("/\\*" + "|" + "\\*/", "g");
				var firstLine = model.getLineAtOffset(selection.start);
				var lastLine = model.getLineAtOffset(selection.end);
				
				var result = findEnclosingComment(model, selection.start, selection.end);
				if (result.commentStart !== undefined && result.commentEnd !== undefined) {
					return true; // Already in a comment
				}
				
				var text = model.getText(selection.start, selection.end);
				if (text.length === 0) { return true; }
				
				var oldLength = text.length;
				text = text.replace(commentTags, "");
				var newLength = text.length;
				
				this.startUndo();
				model.setText(open + text + close, selection.start, selection.end);
				this.editorWidget.setSelection(selection.start + open.length, selection.end + open.length + (newLength-oldLength));
				this.endUndo();
			}));
			
			this.editorWidget.setKeyBinding(new eclipse.KeyBinding(220, true, true), "remove block comment");
			this.editorWidget.setAction("remove block comment", dojo.hitch(this, function() {
				var selection = this.editorWidget.getSelection();
				var model = this.editorWidget.getModel();
				var open = "/*", close = "*/";
				var firstLine = model.getLineAtOffset(selection.start);
				var lastLine = model.getLineAtOffset(selection.end);
				
				// Try to shrink selection to a comment block
				var selectedText = model.getText(selection.start, selection.end);
				var newStart, newEnd;
				var i;
				for(i=0; i < selectedText.length; i++) {
					if (selectedText.substring(i, i + open.length) === open) {
						newStart = selection.start + i;
						break;
					}
				}
				for (; i < selectedText.length; i++) {
					if (selectedText.substring(i, i + close.length) === close) {
						newEnd = selection.start + i;
						break;
					}
				}
				
				this.startUndo();
				if (newStart !== undefined && newEnd !== undefined) {
					model.setText(model.getText(newStart + open.length, newEnd), newStart, newEnd + close.length);
					this.editorWidget.setSelection(newStart, newEnd);
				} else {
					// Otherwise find enclosing comment block
					var result = findEnclosingComment(model, selection.start, selection.end);
					if (result.commentStart === undefined || result.commentEnd === undefined) {
						return true;
					}
					
					var text = model.getText(result.commentStart + open.length, result.commentEnd);
					model.setText(text, result.commentStart, result.commentEnd + close.length);
					this.editorWidget.setSelection(selection.start - open.length, selection.end - close.length);
				}
				this.endUndo();
			}));
			
			//Auto indent
			this.editorWidget.setAction("enter", dojo.hitch(this, function() {
				if (this.contentAssist && this.contentAssist.isActive()) {
					return this.contentAssist.enter();
				}
				var selection = this.editorWidget.getSelection();
				if (selection.start === selection.end) {
					var model = this.editorWidget.getModel();
					var lineIndex = model.getLineAtOffset(selection.start);
					var lineText = model.getLine(lineIndex);
					var index = 0, c;
					while ((c = lineText.charCodeAt(index)) === 32 || c === 9) { index++; }
					if (index > 0) {
						this.editorWidget.setText(model.getLineDelimiter() + lineText.substring(0, index), selection.start, selection.end);
						return true;
					}
				}
				return false;
			}));
		},
	
		cancel: function() {
			return false;
		},
		isActive: function() {
			return false;  // we have no modal interactions
		},
		lineUp: function() {
			return false;
		},
		lineDown: function() {
			return false;
		},
		enter: function() {
			return false;
		}
	};
	return SourceCommands;
}());

